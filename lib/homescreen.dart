import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;

import 'model.dart';

class homescreen extends StatefulWidget {
  const homescreen({super.key});

  @override
  State<homescreen> createState() => _homescreenState();
}

class _homescreenState extends State<homescreen> {
  final ValueNotifier<bool> isSheetOpenNotifier = ValueNotifier(false);

  List<University> universityList = [];
  bool _isLoading = false;
  int _page = 1; // Track the current page of data

  ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_scrollListener);
    _fetchData();
  }

  void _scrollListener() {
    if (_scrollController.position.pixels ==
        _scrollController.position.maxScrollExtent) {
      _fetchData();
    }
  }

  Future<void> _fetchData() async {
    if (_isLoading) return;
    setState(() {
      _isLoading = true;
    });
    try {
      final response = await http.get(Uri.parse(
          'https://jsonplaceholder.typicode.com/photos?_page=$_page&_limit=10'));

      if (response.statusCode == 200) {
        var data = jsonDecode(response.body.toString());

        for (Map i in data) {
          University autogenerated =
          University(url: i['url'], title: i['title']);
          universityList.add(autogenerated);
        }

        _page++;
        setState(() {}); // Refresh the UI after fetching data
      } else {
        print('Error: ${response.statusCode}');
      }
    } catch (e) {
      print('Error: $e');
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  List<int> _likes =
  List<int>.generate(10, (index) => 0); // Initially all images have 0 likes
  List<List<String>> _comments = List<List<String>>.generate(
      10, (index) => []); // Initially all images have no comments

  void _toggleLike(int index) {
    setState(() {
      if (_likes[index] == 0) {
        _likes[index] = 1;
      } else {
        _likes[index] = 0;
      }
    });
  }

  void _addComment(int index, String comment) {
    setState(() {
      _comments[index].add(comment);
    });
  }

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      controller: _scrollController,
      itemCount: _isLoading ? universityList.length + 1 : universityList.length,
      itemBuilder: (BuildContext context, int index) {
        if (index == universityList.length) {
          return Center(child: CircularProgressIndicator());
        }
        if (_likes.length <= index) {
          _likes.addAll(List<int>.generate(
              universityList.length - _likes.length, (index) => 0));
        }
        if (_comments.length <= index) {
          _comments.addAll(List<List<String>>.generate(
              universityList.length - _comments.length, (index) => []));
        }
        return Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: <Widget>[
              ClipRRect(
                borderRadius: BorderRadius.circular(20),
                child: Image.network(
                  universityList[index].url.toString(),
                  fit: BoxFit.cover,
                  height: 300.0,
                ),
              ),
              Row(
                children: <Widget>[
                  IconButton(
                    icon: _likes[index] == 1
                        ? Icon(Icons.favorite, color: Colors.red)
                        : Icon(Icons.favorite_border),
                    onPressed: () {
                      _toggleLike(index);
                    },
                  ),
                  IconButton(
                    icon: Icon(Icons.mode_comment_outlined),
                    onPressed: () {
                      // Implement commenting functionality here
                      showDialog(
                        context: context,
                        builder: (BuildContext context) {
                          String newComment = '';
                          return AlertDialog(
                            title: Text('Add Comment'),
                            content: TextField(
                              onChanged: (value) {
                                newComment =
                                    value; // Update the comment as the user types
                              },
                              decoration:
                              InputDecoration(hintText: 'Enter your comment'),
                            ),
                            actions: <Widget>[
                              TextButton(
                                child: Text('CANCEL'),
                                onPressed: () {
                                  Navigator.of(context).pop();
                                },
                              ),
                              TextButton(
                                child: Text('COMMENT'),
                                onPressed: () {
                                  // Add the actual comment to the image
                                  _addComment(index, newComment);
                                  Navigator.of(context).pop();
                                },
                              ),
                            ],
                          );
                        },
                      );
                    },
                  ),
                ],
              ),
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: _comments[index]
                    .map((comment) =>
                    Padding(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 8.0, vertical: 4.0),
                      child: Text(
                        comment,
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 20,
                          fontWeight: FontWeight.normal,
                          decoration: TextDecoration.none,
                        ),
                      ),
                    ))
                    .toList(),
              ),
            ],
          ),
        );
      },
    );
  }
}
